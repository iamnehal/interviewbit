 bool isValid(int x,int y,int n,int m,vector<vector<int>>&v)
    {



if(x<0 || y<0 || x>=n || y>=m)return 0;
if(v[x][y]!=1)return 0;
//if(v[x][y]==1)return 0;
return 1;


    }

int dx[]={ 0,1,1,1,0,-1,-1,-1  };
int dy[]={ 1,1,0,-1,-1,-1,0,1,}  ;









int Solution::solve(vector<vector<int> > &A) {
int N=A.size();
int M=A[0].size();
int ans=0;
// vector<vector<int>>dis(N,vector<int>(M,0));
  //vector<vector<int>>vis(N,vector<int>(M,0));
int i,j;
for(i=0;i<N;i++)
{
    for(j=0;j<M;j++)
    {
        if( A[i][j]==1)
        {
 int curr=0;
       queue<pair<int,int>>q;
       int x,y;
       x=i;y=j;
       q.push({x,y});
       A[x][y]=2;

       while(q.empty()==0)
       {
           int tx=q.front().first;
           int ty=q.front().second;
           curr++;
           q.pop();
           for(int k=0;k<8;k++)
           {   int newx=tx+dx[k];
           int newy=ty+dy[k];

  if(isValid(newx,newy,N,M,A))
  {
    
   A[newx][newy]=2;
   q.push({newx,newy});

  }

           }

       }

ans=max(curr,ans);
        }



    }
}


 

return ans;

}









Fastest
Lightweight
bool isPossible(int X,int Y,int N,int M){
    if(X>=0 && X<N && Y>=0 && Y<M){
        return true;
    }
    return false;
}

void dfs(vector<vector<int>> &A,vector<vector<bool>> &visited,int N,int M,int x,int y,int &ct){
    
    visited[x][y] = true;
    ct++;
    
    if(isPossible(x+1,y,N,M)  && visited[x+1][y]==false && A[x+1][y]==1){
        dfs(A,visited,N,M,x+1,y,ct);
    }
    if(isPossible(x-1,y,N,M)  && visited[x-1][y]==false && A[x-1][y]==1){
        dfs(A,visited,N,M,x-1,y,ct);
    }
    if(isPossible(x,y+1,N,M)  && visited[x][y+1]==false && A[x][y+1]==1){
        dfs(A,visited,N,M,x,y+1,ct);
    }
    if(isPossible(x,y-1,N,M)  && visited[x][y-1]==false && A[x][y-1]==1){
        dfs(A,visited,N,M,x,y-1,ct);
    }
    if(isPossible(x+1,y+1,N,M)  && visited[x+1][y+1]==false && A[x+1][y+1]==1){
        dfs(A,visited,N,M,x+1,y+1,ct);
    }
    if(isPossible(x-1,y-1,N,M)  && visited[x-1][y-1]==false && A[x-1][y-1]==1){
        dfs(A,visited,N,M,x-1,y-1,ct);
    }
    if(isPossible(x+1,y-1,N,M)  && visited[x+1][y-1]==false && A[x+1][y-1]==1){
        dfs(A,visited,N,M,x+1,y-1,ct);
    }
    if(isPossible(x-1,y+1,N,M)  && visited[x-1][y+1]==false && A[x-1][y+1]==1){
        dfs(A,visited,N,M,x-1,y+1,ct);
    }
}

int Solution::solve(vector<vector<int> > &A) {
    int N = A.size();
    int M = A[0].size();
    
    int ans=0;
    vector<vector<bool>> visited(N ,vector<bool> (M, false));
    
    for(int i=0;i<N;++i){
        for(int j=0;j<M;++j){
            
            if(visited[i][j] == false && A[i][j] == 1){
                int ct=0;
                
                dfs(A,visited,N,M,i,j,ct);
                
                ans = max(ans, ct);
            }
        }
    }
    return ans;
}
